# Stop Malware at Upload Time: A Practical Node.js Pipeline with pompelmi

**TL;DR:** Learn how to build a production-ready file upload security pipeline in Node.js that scans files for malware before they hit diskâ€”no cloud dependencies, fully private, and framework-agnostic.

---

## The Problem: Untrusted File Uploads Are a Vector

Every file upload is a potential attack vector. Whether you're building a document management system, a social media platform, or an e-commerce site, accepting user files without validation is asking for trouble:

- **Malware distribution:** Users upload infected files that spread to other users
- **Server compromise:** Executable files or scripts exploit server vulnerabilities
- **Data exfiltration:** Polyglot files bypass filters and extract sensitive data
- **Resource exhaustion:** ZIP bombs and nested archives consume server resources
- **Compliance violations:** HIPAA, PCI DSS, and GDPR require security controls

Traditional approaches fall short:
- **Client-side validation:** Easily bypassed
- **Extension filtering alone:** Insufficient (`.jpg.exe`)
- **Post-upload scanning:** Too lateâ€”file already on disk
- **Cloud AV APIs:** Privacy concerns, latency, vendor lock-in

## The Solution: In-Process Scanning with pompelmi

**pompelmi** is a privacy-first malware scanner for Node.js that runs entirely in your process. No external dependencies, no data leaks, no network latency.

### Key Benefits

âœ… **Privacy guaranteed** â€” Files never leave your infrastructure  
âœ… **Scan before disk** â€” Block threats at the edge  
âœ… **Framework adapters** â€” Drop-in for Express, Koa, Next.js, NestJS  
âœ… **Multi-layered defense** â€” MIME sniffing, heuristics, YARA support  
âœ… **Production-ready** â€” ZIP bomb protection, timeouts, configurable policies  

---

## Building a Secure Upload Pipeline

### Step 1: Install pompelmi

```bash
npm install pompelmi @pompelmi/express-middleware
```

### Step 2: Create a Security Policy

Start with a **policy preset**â€”pompelmi v0.27+ includes three production-tested configurations:

```typescript
import { scan } from 'pompelmi';

// Strict: High-security environments
const result = await scan(buffer, { preset: 'strict' });

// Balanced: Recommended for most apps
const result = await scan(buffer, { preset: 'balanced' });

// Fast: Performance-critical, trusted sources
const result = await scan(buffer, { preset: 'fast' });
```

| Preset | Max Depth | Buffer Size | Heuristic Threshold | Use Case |
|--------|-----------|-------------|---------------------|----------|
| `strict` | 2 levels | 5MB | 60/100 | Healthcare, finance, public uploads |
| `balanced` | 4 levels | 10MB | 75/100 | General production (recommended) |
| `fast` | 1 level | 20MB | 85/100 | Internal tools, trusted users |

### Step 3: Add Express Middleware

```typescript
import express from 'express';
import multer from 'multer';
import { createUploadGuard } from '@pompelmi/express-middleware';
import { scan, ReasonCode } from 'pompelmi';

const app = express();
const upload = multer({ storage: multer.memoryStorage() });

// Wrap core scanner in adapter-compatible interface
const scanner = {
  async scan(bytes) {
    const result = await scan(Buffer.from(bytes), { preset: 'balanced' });
    return result.findingsWithReasons || [];
  }
};

app.post('/upload',
  upload.single('file'),
  createUploadGuard({
    scanner,
    maxFileSizeBytes: 10 * 1024 * 1024, // 10MB
    includeExtensions: ['pdf', 'jpg', 'png', 'zip'],
    allowedMimeTypes: ['application/pdf', 'image/jpeg', 'image/png', 'application/zip'],
    failClosed: true, // Block on errors
    onScanEvent: (event) => console.log('[scan]', event)
  }),
  (req, res) => {
    const scanResult = req.pompelmi;
    
    if (scanResult?.verdict === 'malicious') {
      return res.status(422).json({
        error: 'Malicious file detected',
        findings: scanResult.findings
      });
    }

    res.json({
      success: true,
      fileName: req.file.originalname,
      verdict: scanResult?.verdict || 'clean'
    });
  }
);

app.listen(3000);
```

### Step 4: Use Reason Codes for Automation

pompelmi v0.27 introduces **standardized reason codes** for automated decision-making:

```typescript
import { scan, ReasonCode } from 'pompelmi';

async function processUpload(buffer) {
  const result = await scan(buffer, { preset: 'balanced' });
  
  if (!result.findingsWithReasons) {
    return { action: 'allow' };
  }

  // Auto-reject malware
  const hasMalware = result.findingsWithReasons.some(f =>
    [
      ReasonCode.MALWARE_SIGNATURE_MATCH,
      ReasonCode.MALWARE_YARA_MATCH,
      ReasonCode.ARCHIVE_BOMB_DETECTED
    ].includes(f.reasonCode)
  );

  if (hasMalware) {
    await logSecurityEvent('malware_rejected', result);
    return { action: 'reject', reason: 'Malware detected' };
  }

  // Quarantine suspicious files
  const needsReview = result.findingsWithReasons.some(f =>
    [
      ReasonCode.FILE_POLYGLOT,
      ReasonCode.ARCHIVE_TOO_DEEP,
      ReasonCode.FILE_EMBEDDED_SCRIPT
    ].includes(f.reasonCode)
  );

  if (needsReview) {
    await quarantineFile(buffer);
    await notifySecurityTeam(result);
    return { action: 'quarantine' };
  }

  return { action: 'allow' };
}
```

---

## Production Deployment Checklist

### Security Hardening

- [x] **Use policy presets** â€” Start with `balanced` or `strict`
- [x] **Set failClosed: true** â€” Block uploads if scanner fails
- [x] **Restrict MIME types** â€” Only allow what you need
- [x] **Enforce file size limits** â€” Prevent resource exhaustion
- [x] **Enable ZIP inspection** â€” Detect bombs and traversal attacks
- [x] **Sanitize filenames** â€” Strip path traversal characters

### Operational Excellence

- [x] **Log all scans** â€” Track verdicts by reason code
- [x] **Monitor metrics** â€” Alert on malware detections
- [x] **Set up quarantine** â€” Store suspicious files for review
- [x] **Test with EICAR** â€” Verify scanner is working
- [x] **Review logs regularly** â€” Identify patterns and false positives

### Performance Optimization

- [x] **Choose appropriate preset** â€” Use `fast` for trusted sources
- [x] **Configure concurrency** â€” Parallel scanning for high throughput
- [x] **Enable streaming** â€” Memory-efficient for large files
- [x] **Set reasonable timeouts** â€” Prevent slow scans from blocking

---

## Framework Examples

### Next.js App Router

```typescript
// app/api/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { scan, ReasonCode } from 'pompelmi';

export const runtime = 'nodejs';

export async function POST(req: NextRequest) {
  const formData = await req.formData();
  const file = formData.get('file') as File;
  const buffer = Buffer.from(await file.arrayBuffer());

  const result = await scan(buffer, { preset: 'strict' });

  if (result.verdict === 'malicious') {
    return NextResponse.json(
      { error: 'Malware detected', findings: result.findingsWithReasons },
      { status: 422 }
    );
  }

  return NextResponse.json({ success: true, verdict: result.verdict });
}
```

### Koa

```typescript
import Koa from 'koa';
import Router from '@koa/router';
import multer from '@koa/multer';
import { createKoaUploadGuard } from '@pompelmi/koa-middleware';

const app = new Koa();
const router = new Router();
const upload = multer({ storage: multer.memoryStorage() });

router.post('/upload',
  upload.single('file'),
  createKoaUploadGuard({
    scanner,
    maxFileSizeBytes: 10 * 1024 * 1024,
    failClosed: true
  }),
  (ctx) => {
    ctx.body = { success: true, verdict: ctx.pompelmi?.verdict };
  }
);

app.use(router.routes());
app.listen(3000);
```

### NestJS

```typescript
import { Controller, Post, UseGuards, UploadedFile } from '@nestjs/common';
import { PompelmiGuard } from '@pompelmi/nestjs-integration';

@Controller('upload')
export class UploadController {
  @Post()
  @UseGuards(PompelmiGuard)
  uploadFile(@UploadedFile() file: Express.Multer.File) {
    return { success: true, fileName: file.originalname };
  }
}
```

---

## Advanced: Monitoring and Alerting

Track security metrics by reason code:

```typescript
import { scan, getReasonCodeInfo } from 'pompelmi';

async function scanWithMetrics(buffer, metadata) {
  const result = await scan(buffer, { preset: 'balanced' });

  // Track metrics by reason code
  if (result.findingsWithReasons) {
    for (const finding of result.findingsWithReasons) {
      const info = getReasonCodeInfo(finding.reasonCode);
      
      metrics.increment('file_scan.finding', {
        reason_code: finding.reasonCode,
        severity: info.severity,
        user_id: metadata.userId
      });
    }
  }

  // Alert on malware
  if (result.verdict === 'malicious') {
    await sendAlert({
      type: 'malware_detected',
      severity: 'critical',
      findings: result.findingsWithReasons,
      metadata
    });
  }

  return result;
}
```

---

## Copy-Paste Checklist

```bash
# 1. Install pompelmi
npm install pompelmi @pompelmi/express-middleware

# 2. Test with EICAR (safe test file)
echo 'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' > eicar.txt
curl -F "file=@eicar.txt" http://localhost:3000/upload

# 3. Monitor logs
tail -f logs/security.log | grep "verdict=malicious"

# 4. Set up alerts (example: Slack webhook)
curl -X POST https://hooks.slack.com/services/YOUR/WEBHOOK/URL \
  -H 'Content-Type: application/json' \
  -d '{"text":"ðŸš¨ Malware detected in upload"}'
```

---

## Conclusion

Building a secure file upload pipeline doesn't require complex infrastructure or third-party services. With pompelmi, you can:

âœ… Scan files in-process before they hit disk  
âœ… Use production-tested policy presets  
âœ… Build automated workflows with reason codes  
âœ… Maintain privacy and compliance  
âœ… Deploy across any Node.js framework  

**Get Started:**  
- [GitHub Repository](https://github.com/pompelmi/pompelmi)
- [Documentation](https://pompelmi.github.io/pompelmi/)
- [Examples](https://github.com/pompelmi/pompelmi/tree/main/examples)

**Questions? Found this useful?** Star the repo and join the discussion!

---

*Published: January 2026 | Tags: Node.js, Security, Malware Detection, File Upload, Express, Next.js*
